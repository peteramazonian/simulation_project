from time_management import add_to_fel, clock, postponed_rest_fel_editor

# Creating class ServiceStation
# Our service stations are objects of this class
# Costumer arrivals, departures, servers leaving for rest and getting back to work are handled here


class ServiceStation:
    def __init__(self, name, service_time_generator, available_servers):
        self.name = name                                        # What you call this station in real world
        self.service_time_generator = service_time_generator    # Service_time_generator is an object of TimeGenerator class
        self.available_servers = available_servers              # Number of servers working in this ServiceStation
        self.busy_servers = 0                                   # Number of busy servers at the beginning of the simulation. Usually equals to 0
        self.queue_list = []                                    # List of costumers waiting in queue for this station. queue_list elements: (queue_joined_time, costumer_id)
        self.position = 1                                       # ** AUTOGENERATED in main **. position = n if this is the n'th service station costumers get into.
        self.rest_in_waiting = 0                                # When there is a server waiting to finish the serve, then go to rest, this will be equal to 1
        self.server_rest_duration = 10                          # How long is each server's rest duration

    # Overriding Python's original __repr__ function
    def __repr__(self):
        return self.name

    def arrival(self, costumer_id):
        if self.busy_servers < self.available_servers:
            self.busy_servers += 1
            event_notice = (self.service_time_generator.generate() + clock, "D" + str(self.position), costumer_id, self.departure)
            # TODO edit add to fel . clock is added here
            add_to_fel(event_notice)
        else:
            self.queue_list.append((clock, costumer_id))

    def departure(self, costumer_id):
        if not self.rest_in_waiting:
            if self.queue_list.__len__() > 0:
                event_notice = (self.service_time_generator.generate() + clock, "D" + str(self.position), self.queue_list[0][1], self.departure)
                add_to_fel(event_notice)
                del self.queue_list[0]
            else:
                self.busy_servers -= 1
        else:
            self.rest_in_waiting = 0
            self.busy_servers -= 1
            event_notice = (clock, "R" + str(self.position), self.server_rest)
            postponed_rest_fel_editor(event_notice)
        # TODO add movement class?!
        movement(clock, costumer_id, self.position)

    def server_rest(self):
        if self.busy_servers < self.available_servers:
            self.available_servers -= 1
            event_notice = (self.server_rest_duration + clock, "B" + str(self.position), self.server_back)
            add_to_fel(event_notice)
        else:
            self.rest_in_waiting = 1
            postponed_rest_fel_editor()

    def server_back(self):
        self.available_servers += 1
        if self.queue_list.__len__() > 0:
            event_notice = (self.service_time_generator.generate() + clock, "D" + str(self.position), self.queue_list[0][1], self.departure)
            add_to_fel(event_notice)
            del self.queue_list[0]
